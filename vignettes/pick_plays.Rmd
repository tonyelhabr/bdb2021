---
title: 'pick_plays'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pick_plays}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = '#>'
)
```

```{r setup}
library(bdb2021)
library(tidyverse)
```

```{r}
games <- bdb2021::import_games()
plays <- bdb2021::import_plays()
weeks <- 1L # 1L:17L
tracking <- weeks %>% bdb2021::import_week()
# tracking <- 
#   weeks %>% 
#   tibble::tibble(week = .) %>% 
#   dplyr::mutate(data = purrr::map(week, bdb2021::import_week)) %>% 
#   tidyr::unnest(data)
```

```{r}
snap_frames <- tracking %>% dplyr::filter(event == 'ball_snap')
snap_frames %>%
  dplyr::filter(position == 'RB') %>%
  dplyr::filter(!is.na(route)) %>% 
  dplyr::inner_join(plays) %>%
  dplyr::mutate(x_relative = x - ball_x) %>%
  ggplot2::ggplot() +
  ggplot2::aes(x = x_relative) +
  ggplot2::geom_histogram(binwidth = 1) +
  ggplot2::geom_vline(ggplot2::aes(xintercept = -2.5)) +
  ggplot2::facet_grid(offense_formation~., scales = 'free_y') +
  ggplot2::labs(y = NULL, x = NULL)
```

```{r}
snap_frames %>%
  dplyr::filter(position == 'TE') %>%
  dplyr::filter(!is.na(route)) %>% 
  dplyr::inner_join(plays) %>%
  dplyr::mutate(
    y_relative = y - ball_y # ,
    # dplyr::across(y_relative, ~cut(.x, breaks = seq(-6, 6, by = 1)))
  ) %>%
  ggplot2::ggplot() +
  ggplot2::aes(x = y_relative) +
  # ggplot2::geom_bar() +
  ggplot2::geom_histogram(
    # binwidth = 1
    breaks = seq(-6, 6, by = 0.5)
  ) +
  ggplot2::geom_vline(
    data = tibble::tibble(xintercept = c(-3, 3)),
    ggplot2::aes(xintercept = xintercept)
  ) +
  ggplot2::facet_grid(offense_formation~., scales = 'free_y') +
  ggplot2::labs(y = NULL, x = NULL)
```

```{r}
tracking <- tracking %>% bdb2021::add_side_cols()
```

```{r}
tracking_at_end_routes <- tracking %>% bdb2021::clip_tracking_at_events('end_routes')
tracking_at_throw <- tracking %>% bdb2021::clip_tracking_at_events('throw')
```

```{r include=F, echo=F, eval=F}
end_route_w_pass_ids <-
  tracking_at_end_routes %>%
  # filter(game_id == 2018092301, play_id == 453) %>% 
  dplyr::filter(side == 'O' & position != 'QB') %>% 
  # Don't look at sacks, etc.
  dplyr::filter(event %>% stringr::str_detect('^pass_outcome_')) %>%
  dplyr::group_by(game_id, play_id) %>% 
  dplyr::summarize(n_na_route = sum(is.na(route)), n_route = dplyr::n()) %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(n_na_route < n_route) %>% 
  dplyr::distinct(game_id, play_id)
end_route_w_pass_ids

slice_at <- function(x, f) {
  x %>% 
    group_by(game_id, play_id, nfl_id) %>% 
    filter(frame_id == f(frame_id)) %>% 
    ungroup()
}

slice_at_max <- purrr::partial(slice_at, f = max, ... = )
slice_at_min <- purrr::partial(slice_at, f = min, ... = )

summarize_events <- function(x1, x2, pass_ids = end_route_w_pass_ids) {

  dplyr::bind_rows(
    x1 %>% 
      dplyr::mutate(event = 'start'),
    x2 %>% 
      dplyr::mutate(event = 'end')
  ) %>% 
    dplyr::semi_join(pass_ids, by = c('game_id', 'play_id')) %>% 
    dplyr::distinct(game_id, play_id, event, frame_id, ball_x, ball_y) %>% 
    tidyr::pivot_wider(names_from = event, values_from = c(ball_x, ball_y, frame_id)) %>%
    dplyr::mutate(
      sec_diff = (frame_id_end - frame_id_start) * 0.1,
      x_diff = ball_x_end - ball_x_start,
      y_diff = ball_y_end - ball_y_start,
      dist = sqrt(x_diff^2 + y_diff^2)
    )
}

# Theoretically, probably should use the "pass arrive" events instead of the various 
# "end route" events to get a more accurate pass distance.
# In practice, I didn't like how the ids matched up. (Too many plays with
# missing "pass arrive" events.
pass_dists <-
  summarize_events(
    tracking_at_throw %>% slice_at_max(),
    tracking_at_end_routes %>% slice_at_max()
  )
pass_dists

time_till_throw <-
  summarize_events(
    tracking_at_throw %>% slice_at_min(),
    tracking_at_throw %>% slice_at_max()
  )
time_till_throw
```

```{r}
snap_frames <- tracking %>% dplyr::filter(event == 'ball_snap')
receivers_at_snap <- snap_frames %>% bdb2021::add_idx_y_col()
receivers_at_snap
```

```{r}
# Note that there are plays without routes, including some completions and incompletions.
snap_frames_n <-
  snap_frames %>%
  # Probably should use `end_route_w_pass_ids`?
  # semi_join(end_route_w_pass_ids, by = c('game_id', 'play_id'))
  filter(side == 'O' & position != 'QB') %>% 
  group_by(game_id, play_id, frame_id) %>% 
  summarize(n_route_na = sum(is.na(route)), n_route = n()) %>% 
  ungroup() %>% 
  # Don't really need `epa` here, but it's a nice add. 
  # Because I add it here, I don't need to add it later when joining on `snap_frames_n`.
  inner_join(
    plays %>% 
      select(game_id, play_id, pass_result, epa), 
    by = c('game_id', 'play_id')
  )
snap_frames_n
```

```{r include=F, echo=F, eval=F}
# Seeing what fraction of each pass result is missing routes.
snap_frames_n %>% 
  count(
    pass_result, 
    all_na_routes = ifelse(n_route_na == n_route, 'no_routes', 'has_routes')
  ) %>% 
  pivot_wider(names_from = all_na_routes, values_from = n, values_fill = 0L) %>% 
  mutate(frac = no_routes / (no_routes + has_routes))
```

```{r}
snap_frame_ids <- snap_frames %>% distinct(game_id, play_id, frame_id)
n_halfseconds <- 7
seconds_frames <-
  snap_frame_ids %>% 
  # Only need up to 3.5 seconds (0, 0.5, 1, ..., 3.5) since that is my arbitrary cutoff.
  mutate(n = !!n_halfseconds) %>% 
  uncount(n) %>%
  group_by(game_id, play_id) %>%
  # Create half seconds.
  mutate(
    sec = (row_number() - 1L) / 2
  ) %>% 
  ungroup() %>% 
  mutate(
    # Need this `event` column for something... I think with the `add_idx_y_col()` function.
    # event = sprintf('%.1f_sec_post_snap', sec)
    frame_id = frame_id + sec * 10, 
  ) %>% 
  # select(-sec) %>% 
  inner_join(
    tracking_at_throw %>% 
      select(-event), 
    by = c('frame_id', 'game_id', 'play_id')
  )
seconds_frames
```

```{r}
receivers_at_seconds <-
  seconds_frames %>%
  # Use the `y_side` from the snap time, not at a gvien seconds' time.
  select(-x_side, -y_side) %>%
  inner_join(
    seconds_frames %>%
      # Filter to ball snap time.
      filter(sec == 0) %>%
      # Only consider receivers not in the backfield nor starting in the middle
      # of the field.
      bdb2021::drop_ineligible_pick_route_frames() %>% 
      group_by(game_id, play_id, y_side, x_side, frame_id) %>%
      mutate(n_route = n()) %>%
      ungroup() %>%
      select(game_id, play_id, nfl_id, x_side, y_side, n_route),
    by = c('game_id', 'play_id', 'nfl_id')
  ) %>%
  # add_idx_y_col() %>%
  rename(x_side_init = x_side, y_side_init = y_side)
receivers_at_seconds
```

```{r}
# Sensitivity test
intersections_after <- function(data = receivers_at_seconds, sec) {
  data_nested <-
    data %>%
    filter(n_route >= 2L) %>%
    filter(sec <= !!sec) %>%
    group_by(game_id, play_id) %>%
    filter(max(sec) >= !!sec) %>%
    ungroup() %>%
    select(game_id, play_id, y_side_init, nfl_id, frame_id, x, y) %>%
    nest(data = c(nfl_id, frame_id, x, y))
  n_row <- data_nested %>% nrow()
  n_intersection <-
    data_nested %>%
    mutate(
      intersection = map(data, identify_intersection),
      has_intersection = map_lgl(intersection, ~nrow(.x) > 0),
    ) %>%
    filter(has_intersection) %>%
    select(-data, -has_intersection) %>%
    mutate(n_intersection = map_dbl(intersection, ~nrow(.x) / 2L)) %>%
    summarize(across(n_intersection, sum)) %>%
    pull(n_intersection)
  tibble(n_max = n_row, n_intersection = n_intersection)
}

# Tallying how many intersections happen up through x seconds after the ball has been snapped.
intersections_n <-
  tibble(
    # sec = seq(0.5, by = 0.5, length.out = n_halfseconds)
    sec = 0.5
  ) %>%
  mutate(data = map(sec, ~intersections_after(data = receivers_at_seconds, sec = .x))) %>%
  unnest(data)
intersections_n
```

```{r }
intersections_n %>%
  filter(sec >= 0.5) %>%
  mutate(frac_intersection = n_intersection / n_max)
```

```{r}
```
